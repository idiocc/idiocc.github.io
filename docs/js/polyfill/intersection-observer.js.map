{
"version":3,
"file":"internal/js/polyfill/intersection-observer.js",
"lineCount":20,
"mappings":"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",
"sources":["src/js/polyfill/intersection-observer.js"],
"sourcesContent":["/* eslint-env browser */\n/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\n *\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n */\n(function() {\n  'use strict'\n\n  // Exit early if we're not running in a browser.\n  if (typeof window !== 'object') {\n    return\n  }\n\n  // Exit early if all IntersectionObserver and IntersectionObserverEntry\n  // features are natively supported.\n  if ('IntersectionObserver' in window &&\n      'IntersectionObserverEntry' in window &&\n      'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n    // Minimal polyfill for Edge 15's lack of `isIntersecting`\n    // See: https://github.com/w3c/IntersectionObserver/issues/211\n    if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n      Object.defineProperty(window.IntersectionObserverEntry.prototype,\n        'isIntersecting', {\n          get: function () {\n            return this.intersectionRatio > 0\n          },\n        })\n    }\n    return\n  }\n\n\n  /**\n   * A local reference to the document.\n   */\n  var document = window.document\n\n\n  /**\n   * An IntersectionObserver registry. This registry exists to hold a strong\n   * reference to IntersectionObserver instances currently observing a target\n   * element. Without this registry, instances without another reference may be\n   * garbage collected.\n   */\n  var registry = []\n\n\n  /**\n   * Creates the global IntersectionObserverEntry constructor.\n   * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n   * @param {Object} entry A dictionary of instance properties.\n   * @implements {IntersectionObserverEntry}\n   * @constructor\n   */\n  function IntersectionObserverEntry(entry) {\n    this.time = entry.time\n    this.target = entry.target\n    this.rootBounds = entry.rootBounds\n    this.boundingClientRect = entry.boundingClientRect\n    this.intersectionRect = entry.intersectionRect || getEmptyRect()\n    this.isIntersecting = !!entry.intersectionRect\n\n    // Calculates the intersection ratio.\n    var targetRect = this.boundingClientRect\n    var targetArea = targetRect.width * targetRect.height\n    var intersectionRect = this.intersectionRect\n    var intersectionArea = intersectionRect.width * intersectionRect.height\n\n    // Sets intersection ratio.\n    if (targetArea) {\n      // Round the intersection ratio to avoid floating point math issues:\n      // https://github.com/w3c/IntersectionObserver/issues/324\n      this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4))\n    } else {\n      // If area is zero and is intersecting, sets to 1, otherwise to 0\n      this.intersectionRatio = this.isIntersecting ? 1 : 0\n    }\n  }\n\n\n  /**\n   * Creates the global IntersectionObserver constructor.\n   * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n   * @param {Function} callback The function to be invoked after intersection\n   *     changes have queued. The function is not invoked if the queue has\n   *     been emptied by calling the `takeRecords` method.\n   * @param {Object=} opt_options Optional configuration options.\n   * @extends {IntersectionObserver}\n   * @constructor\n   */\n  function IntersectionObserver(callback, opt_options) {\n    var options = opt_options || {}\n\n    if (typeof callback != 'function') {\n      throw new Error('callback must be a function')\n    }\n\n    if (options.root && options.root.nodeType != 1) {\n      throw new Error('root must be an Element')\n    }\n\n    // Binds and throttles `this._checkForIntersections`.\n    this._checkForIntersections = throttle(\n      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT)\n\n    // Private properties.\n    this._callback = callback\n    this._observationTargets = []\n    this._queuedEntries = []\n    this._rootMarginValues = this._parseRootMargin(options.rootMargin)\n\n    // Public properties.\n    this.thresholds = this._initThresholds(options.threshold)\n    this.root = options.root || null\n    this.rootMargin = this._rootMarginValues.map(function(margin) {\n      return margin.value + margin.unit\n    }).join(' ')\n  }\n\n\n  /**\n   * The minimum interval within which the document will be checked for\n   * intersection changes.\n   */\n  IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100\n\n\n  /**\n   * The frequency in which the polyfill polls for intersection changes.\n   * this can be updated on a per instance basis and must be set prior to\n   * calling `observe` on the first target.\n   */\n  IntersectionObserver.prototype.POLL_INTERVAL = null\n\n  /**\n   * Use a mutation observer on the root element\n   * to detect intersection changes.\n   */\n  IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true\n\n\n  /**\n   * Starts observing a target element for intersection changes based on\n   * the thresholds values.\n   * @param {Element} target The DOM element to observe.\n   */\n  IntersectionObserver.prototype.observe = function(target) {\n    var isTargetAlreadyObserved = this._observationTargets.some(function(item) {\n      return item.element == target\n    })\n\n    if (isTargetAlreadyObserved) {\n      return\n    }\n\n    if (!(target && target.nodeType == 1)) {\n      throw new Error('target must be an Element')\n    }\n\n    this._registerInstance()\n    this._observationTargets.push({ element: target, entry: null })\n    this._monitorIntersections()\n    this._checkForIntersections()\n  }\n\n\n  /**\n   * Stops observing a target element for intersection changes.\n   * @param {Element} target The DOM element to observe.\n   */\n  IntersectionObserver.prototype.unobserve = function(target) {\n    this._observationTargets =\n        this._observationTargets.filter(function(item) {\n          return item.element != target\n        })\n    if (!this._observationTargets.length) {\n      this._unmonitorIntersections()\n      this._unregisterInstance()\n    }\n  }\n\n\n  /**\n   * Stops observing all target elements for intersection changes.\n   */\n  IntersectionObserver.prototype.disconnect = function() {\n    this._observationTargets = []\n    this._unmonitorIntersections()\n    this._unregisterInstance()\n  }\n\n\n  /**\n   * Returns any queue entries that have not yet been reported to the\n   * callback and clears the queue. This can be used in conjunction with the\n   * callback to obtain the absolute most up-to-date intersection information.\n   * @return {Array} The currently queued entries.\n   */\n  IntersectionObserver.prototype.takeRecords = function() {\n    var records = this._queuedEntries.slice()\n    this._queuedEntries = []\n    return records\n  }\n\n\n  /**\n   * Accepts the threshold value from the user configuration object and\n   * returns a sorted array of unique threshold values. If a value is not\n   * between 0 and 1 and error is thrown.\n   * @private\n   * @param {Array|number=} opt_threshold An optional threshold value or\n   *     a list of threshold values, defaulting to [0].\n   * @return {Array} A sorted list of unique and valid threshold values.\n   */\n  IntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n    var threshold = opt_threshold || [0]\n    if (!Array.isArray(threshold)) threshold = [threshold]\n\n    return threshold.sort().filter(function(t, i, a) {\n      if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n        throw new Error('threshold must be a number between 0 and 1 inclusively')\n      }\n      return t !== a[i - 1]\n    })\n  }\n\n\n  /**\n   * Accepts the rootMargin value from the user configuration object\n   * and returns an array of the four margin values as an object containing\n   * the value and unit properties. If any of the values are not properly\n   * formatted or use a unit other than px or %, and error is thrown.\n   * @private\n   * @param {string=} opt_rootMargin An optional rootMargin value,\n   *     defaulting to '0px'.\n   * @return {Array<Object>} An array of margin objects with the keys\n   *     value and unit.\n   */\n  IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n    var marginString = opt_rootMargin || '0px'\n    var margins = marginString.split(/\\s+/).map(function(margin) {\n      var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin)\n      if (!parts) {\n        throw new Error('rootMargin must be specified in pixels or percent')\n      }\n      return { value: parseFloat(parts[1]), unit: parts[2] }\n    })\n\n    // Handles shorthand.\n    margins[1] = margins[1] || margins[0]\n    margins[2] = margins[2] || margins[0]\n    margins[3] = margins[3] || margins[1]\n\n    return margins\n  }\n\n\n  /**\n   * Starts polling for intersection changes if the polling is not already\n   * happening, and if the page's visibility state is visible.\n   * @private\n   */\n  IntersectionObserver.prototype._monitorIntersections = function() {\n    if (!this._monitoringIntersections) {\n      this._monitoringIntersections = true\n\n      // If a poll interval is set, use polling instead of listening to\n      // resize and scroll events or DOM mutations.\n      if (this.POLL_INTERVAL) {\n        this._monitoringInterval = setInterval(\n          this._checkForIntersections, this.POLL_INTERVAL)\n      }\n      else {\n        addEvent(window, 'resize', this._checkForIntersections, true)\n        addEvent(document, 'scroll', this._checkForIntersections, true)\n\n        if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\n          this._domObserver = new MutationObserver(this._checkForIntersections)\n          this._domObserver.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true,\n          })\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Stops polling for intersection changes.\n   * @private\n   */\n  IntersectionObserver.prototype._unmonitorIntersections = function() {\n    if (this._monitoringIntersections) {\n      this._monitoringIntersections = false\n\n      clearInterval(this._monitoringInterval)\n      this._monitoringInterval = null\n\n      removeEvent(window, 'resize', this._checkForIntersections, true)\n      removeEvent(document, 'scroll', this._checkForIntersections, true)\n\n      if (this._domObserver) {\n        this._domObserver.disconnect()\n        this._domObserver = null\n      }\n    }\n  }\n\n\n  /**\n   * Scans each observation target for intersection changes and adds them\n   * to the internal entries queue. If new entries are found, it\n   * schedules the callback to be invoked.\n   * @private\n   */\n  IntersectionObserver.prototype._checkForIntersections = function() {\n    var rootIsInDom = this._rootIsInDom()\n    var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect()\n\n    this._observationTargets.forEach(function(item) {\n      var target = item.element\n      var targetRect = getBoundingClientRect(target)\n      var rootContainsTarget = this._rootContainsTarget(target)\n      var oldEntry = item.entry\n      var intersectionRect = rootIsInDom && rootContainsTarget &&\n          this._computeTargetAndRootIntersection(target, rootRect)\n\n      var newEntry = item.entry = new IntersectionObserverEntry({\n        time: now(),\n        target: target,\n        boundingClientRect: targetRect,\n        rootBounds: rootRect,\n        intersectionRect: intersectionRect,\n      })\n\n      if (!oldEntry) {\n        this._queuedEntries.push(newEntry)\n      } else if (rootIsInDom && rootContainsTarget) {\n        // If the new entry intersection ratio has crossed any of the\n        // thresholds, add a new entry.\n        if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n          this._queuedEntries.push(newEntry)\n        }\n      } else {\n        // If the root is not in the DOM or target is not contained within\n        // root but the previous entry for this target had an intersection,\n        // add a new record indicating removal.\n        if (oldEntry && oldEntry.isIntersecting) {\n          this._queuedEntries.push(newEntry)\n        }\n      }\n    }, this)\n\n    if (this._queuedEntries.length) {\n      this._callback(this.takeRecords(), this)\n    }\n  }\n\n\n  /**\n   * Accepts a target and root rect computes the intersection between then\n   * following the algorithm in the spec.\n   * TODO(philipwalton): at this time clip-path is not considered.\n   * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n   * @param {Element} target The target DOM element\n   * @param {Object} rootRect The bounding rect of the root after being\n   *     expanded by the rootMargin value.\n   * @return {?Object} The final intersection rect object or undefined if no\n   *     intersection is found.\n   * @private\n   */\n  IntersectionObserver.prototype._computeTargetAndRootIntersection =\n      function(target, rootRect) {\n        // If the element isn't displayed, an intersection can't happen.\n        if (window.getComputedStyle(target).display == 'none') return\n\n        var targetRect = getBoundingClientRect(target)\n        var intersectionRect = targetRect\n        var parent = getParentNode(target)\n        var atRoot = false\n\n        while (!atRoot) {\n          var parentRect = null\n          var parentComputedStyle = parent.nodeType == 1 ?\n            window.getComputedStyle(parent) : {}\n\n          // If the parent isn't displayed, an intersection can't happen.\n          if (parentComputedStyle.display == 'none') return\n\n          if (parent == this.root || parent == document) {\n            atRoot = true\n            parentRect = rootRect\n          } else {\n            // If the element has a non-visible overflow, and it's not the <body>\n            // or <html> element, update the intersection rect.\n            // Note: <body> and <html> cannot be clipped to a rect that's not also\n            // the document rect, so no need to compute a new intersection.\n            if (parent != document.body &&\n            parent != document.documentElement &&\n            parentComputedStyle.overflow != 'visible') {\n              parentRect = getBoundingClientRect(parent)\n            }\n          }\n\n          // If either of the above conditionals set a new parentRect,\n          // calculate new intersection data.\n          if (parentRect) {\n            intersectionRect = computeRectIntersection(parentRect, intersectionRect)\n\n            if (!intersectionRect) break\n          }\n          parent = getParentNode(parent)\n        }\n        return intersectionRect\n      }\n\n\n  /**\n   * Returns the root rect after being expanded by the rootMargin value.\n   * @return {Object} The expanded root rect.\n   * @private\n   */\n  IntersectionObserver.prototype._getRootRect = function() {\n    var rootRect\n    if (this.root) {\n      rootRect = getBoundingClientRect(this.root)\n    } else {\n      // Use <html>/<body> instead of window since scroll bars affect size.\n      var html = document.documentElement\n      var body = document.body\n      rootRect = {\n        top: 0,\n        left: 0,\n        right: html.clientWidth || body.clientWidth,\n        width: html.clientWidth || body.clientWidth,\n        bottom: html.clientHeight || body.clientHeight,\n        height: html.clientHeight || body.clientHeight,\n      }\n    }\n    return this._expandRectByRootMargin(rootRect)\n  }\n\n\n  /**\n   * Accepts a rect and expands it by the rootMargin value.\n   * @param {Object} rect The rect object to expand.\n   * @return {Object} The expanded rect.\n   * @private\n   */\n  IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n    var margins = this._rootMarginValues.map(function(margin, i) {\n      return margin.unit == 'px' ? margin.value :\n        margin.value * (i % 2 ? rect.width : rect.height) / 100\n    })\n    var newRect = {\n      top: rect.top - margins[0],\n      right: rect.right + margins[1],\n      bottom: rect.bottom + margins[2],\n      left: rect.left - margins[3],\n    }\n    newRect.width = newRect.right - newRect.left\n    newRect.height = newRect.bottom - newRect.top\n\n    return newRect\n  }\n\n\n  /**\n   * Accepts an old and new entry and returns true if at least one of the\n   * threshold values has been crossed.\n   * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n   *    particular target element or null if no previous entry exists.\n   * @param {IntersectionObserverEntry} newEntry The current entry for a\n   *    particular target element.\n   * @return {boolean} Returns true if a any threshold has been crossed.\n   * @private\n   */\n  IntersectionObserver.prototype._hasCrossedThreshold = function(oldEntry, newEntry) {\n    // To make comparing easier, an entry that has a ratio of 0\n    // but does not actually intersect is given a value of -1\n    var oldRatio = oldEntry && oldEntry.isIntersecting ?\n      oldEntry.intersectionRatio || 0 : -1\n    var newRatio = newEntry.isIntersecting ?\n      newEntry.intersectionRatio || 0 : -1\n\n    // Ignore unchanged ratios\n    if (oldRatio === newRatio) return false\n\n    for (var i = 0; i < this.thresholds.length; i++) {\n      var threshold = this.thresholds[i]\n\n      // Return true if an entry matches a threshold or if the new ratio\n      // and the old ratio are on the opposite sides of a threshold.\n      if (threshold == oldRatio || threshold == newRatio ||\n      threshold < oldRatio !== threshold < newRatio) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n\n  /**\n   * Returns whether or not the root element is an element and is in the DOM.\n   * @return {boolean} True if the root element is an element and is in the DOM.\n   * @private\n   */\n  IntersectionObserver.prototype._rootIsInDom = function() {\n    return !this.root || containsDeep(document, this.root)\n  }\n\n\n  /**\n   * Returns whether or not the target element is a child of root.\n   * @param {Element} target The target element to check.\n   * @return {boolean} True if the target element is a child of root.\n   * @private\n   */\n  IntersectionObserver.prototype._rootContainsTarget = function(target) {\n    return containsDeep(this.root || document, target)\n  }\n\n\n  /**\n   * Adds the instance to the global IntersectionObserver registry if it isn't\n   * already present.\n   * @private\n   */\n  IntersectionObserver.prototype._registerInstance = function() {\n    if (registry.indexOf(this) < 0) {\n      registry.push(this)\n    }\n  }\n\n\n  /**\n   * Removes the instance from the global IntersectionObserver registry.\n   * @private\n   */\n  IntersectionObserver.prototype._unregisterInstance = function() {\n    var index = registry.indexOf(this)\n    if (index != -1) registry.splice(index, 1)\n  }\n\n\n  /**\n   * Returns the result of the performance.now() method or null in browsers\n   * that don't support the API.\n   * @return {number} The elapsed time since the page was requested.\n   */\n  function now() {\n    return window.performance && performance.now && performance.now()\n  }\n\n\n  /**\n   * Throttles a function and delays its execution, so it's only called at most\n   * once within a given time period.\n   * @param {Function} fn The function to throttle.\n   * @param {number} timeout The amount of time that must pass before the\n   *     function can be called again.\n   * @return {Function} The throttled function.\n   */\n  function throttle(fn, timeout) {\n    var timer = null\n    return function () {\n      if (!timer) {\n        timer = setTimeout(function() {\n          fn()\n          timer = null\n        }, timeout)\n      }\n    }\n  }\n\n\n  /**\n   * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n   * @param {Node} node The DOM node to add the event handler to.\n   * @param {string} event The event name.\n   * @param {Function} fn The event handler to add.\n   * @param {boolean} opt_useCapture Optionally adds the even to the capture\n   *     phase. Note: this only works in modern browsers.\n   */\n  function addEvent(node, event, fn, opt_useCapture) {\n    if (typeof node.addEventListener == 'function') {\n      node.addEventListener(event, fn, opt_useCapture || false)\n    }\n    else if (typeof node.attachEvent == 'function') {\n      node.attachEvent('on' + event, fn)\n    }\n  }\n\n\n  /**\n   * Removes a previously added event handler from a DOM node.\n   * @param {Node} node The DOM node to remove the event handler from.\n   * @param {string} event The event name.\n   * @param {Function} fn The event handler to remove.\n   * @param {boolean} opt_useCapture If the event handler was added with this\n   *     flag set to true, it should be set to true here in order to remove it.\n   */\n  function removeEvent(node, event, fn, opt_useCapture) {\n    if (typeof node.removeEventListener == 'function') {\n      node.removeEventListener(event, fn, opt_useCapture || false)\n    }\n    else if (typeof node.detatchEvent == 'function') {\n      node.detatchEvent('on' + event, fn)\n    }\n  }\n\n\n  /**\n   * Returns the intersection between two rect objects.\n   * @param {Object} rect1 The first rect.\n   * @param {Object} rect2 The second rect.\n   * @return {?Object} The intersection rect or undefined if no intersection\n   *     is found.\n   */\n  function computeRectIntersection(rect1, rect2) {\n    var top = Math.max(rect1.top, rect2.top)\n    var bottom = Math.min(rect1.bottom, rect2.bottom)\n    var left = Math.max(rect1.left, rect2.left)\n    var right = Math.min(rect1.right, rect2.right)\n    var width = right - left\n    var height = bottom - top\n\n    if (width >= 0 && height >= 0) return {\n      top: top,\n      bottom: bottom,\n      left: left,\n      right: right,\n      width: width,\n      height: height,\n    }\n    return null\n  }\n\n\n  /**\n   * Shims the native getBoundingClientRect for compatibility with older IE.\n   * @param {Element} el The element whose bounding rect to get.\n   * @return {Object} The (possibly shimmed) rect of the element.\n   */\n  function getBoundingClientRect(el) {\n    var rect\n\n    try {\n      rect = el.getBoundingClientRect()\n    } catch (err) {\n      // Ignore Windows 7 IE11 \"Unspecified error\"\n      // https://github.com/w3c/IntersectionObserver/pull/205\n    }\n\n    if (!rect) return getEmptyRect()\n\n    // Older IE\n    if (!(rect.width && rect.height)) {\n      rect = {\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top,\n      }\n    }\n    return rect\n  }\n\n\n  /**\n   * Returns an empty rect object. An empty rect is returned when an element\n   * is not in the DOM.\n   * @return {Object} The empty rect.\n   */\n  function getEmptyRect() {\n    return {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      width: 0,\n      height: 0,\n    }\n  }\n\n  /**\n   * Checks to see if a parent element contains a child element (including inside\n   * shadow DOM).\n   * @param {Node} parent The parent element.\n   * @param {Node} child The child element.\n   * @return {boolean} True if the parent node contains the child node.\n   */\n  function containsDeep(parent, child) {\n    var node = child\n    while (node) {\n      if (node == parent) return true\n\n      node = getParentNode(node)\n    }\n    return false\n  }\n\n\n  /**\n   * Gets the parent node of an element or its host element if the parent node\n   * is a shadow root.\n   * @param {Node} node The node whose parent to get.\n   * @return {Node|null} The parent node or null if no parent exists.\n   */\n  function getParentNode(node) {\n    var parent = node.parentNode\n\n    if (parent && parent.nodeType == 11 && parent.host) {\n      // If the parent is a shadow root, return the host element.\n      return parent.host\n    }\n\n    if (parent && parent.assignedSlot) {\n      // If the parent is distributed in a <slot>, return the parent of a slot.\n      return parent.assignedSlot.parentNode\n    }\n\n    return parent\n  }\n\n\n  // Exposes the constructors globally.\n  window.IntersectionObserver = IntersectionObserver\n  window.IntersectionObserverEntry = IntersectionObserverEntry\n}())"],
"names":["IntersectionObserverEntry","entry","time","target","rootBounds","boundingClientRect","intersectionRect","getEmptyRect","isIntersecting","targetRect","targetArea","width","height","intersectionArea","intersectionRatio","Number","toFixed","IntersectionObserver","callback","opt_options","options","Error","root","nodeType","_checkForIntersections","throttle","bind","THROTTLE_TIMEOUT","_callback","_observationTargets","_queuedEntries","_rootMarginValues","_parseRootMargin","rootMargin","thresholds","_initThresholds","threshold","map","margin","value","unit","join","fn","timeout","timer","setTimeout","addEvent","node","event","opt_useCapture","addEventListener","attachEvent","removeEvent","removeEventListener","detatchEvent","getBoundingClientRect","el","rect","err","top","right","bottom","left","containsDeep","parent","child","getParentNode","parentNode","host","assignedSlot","window","prototype","Object","defineProperty","get","document","registry","POLL_INTERVAL","USE_MUTATION_OBSERVER","observe","IntersectionObserver.prototype.observe","isTargetAlreadyObserved","some","item","element","_registerInstance","push","_monitorIntersections","unobserve","IntersectionObserver.prototype.unobserve","filter","length","_unmonitorIntersections","_unregisterInstance","disconnect","IntersectionObserver.prototype.disconnect","takeRecords","IntersectionObserver.prototype.takeRecords","records","slice","IntersectionObserver.prototype._initThresholds","opt_threshold","Array","isArray","sort","t","i","a","isNaN","IntersectionObserver.prototype._parseRootMargin","opt_rootMargin","margins","split","parts","exec","parseFloat","IntersectionObserver.prototype._monitorIntersections","_monitoringIntersections","_monitoringInterval","setInterval","_domObserver","MutationObserver","attributes","childList","characterData","subtree","IntersectionObserver.prototype._unmonitorIntersections","clearInterval","IntersectionObserver.prototype._checkForIntersections","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","forEach","rootContainsTarget","_rootContainsTarget","oldEntry","_computeTargetAndRootIntersection","newEntry","performance","now","_hasCrossedThreshold","IntersectionObserver.prototype._computeTargetAndRootIntersection","getComputedStyle","display","atRoot","parentRect","parentComputedStyle","body","documentElement","overflow","Math","max","min","IntersectionObserver.prototype._getRootRect","html","clientWidth","clientHeight","_expandRectByRootMargin","IntersectionObserver.prototype._expandRectByRootMargin","newRect","IntersectionObserver.prototype._hasCrossedThreshold","oldRatio","newRatio","IntersectionObserver.prototype._rootIsInDom","IntersectionObserver.prototype._rootContainsTarget","IntersectionObserver.prototype._registerInstance","indexOf","IntersectionObserver.prototype._unregisterInstance","index","splice"]
}
